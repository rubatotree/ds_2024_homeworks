#set text(font: ("Noto Serif CJK SC"))
#set page(
  numbering: "1",
)
#set par(
  leading: 1.2em, 
  first-line-indent: 2em
)
#show heading: it => {it;text()[#v(0.3em, weak: true)];text()[#h(0em)]}

#align(center, 
text(17pt)[
  *实验报告1：多项式计算器*
]
)
#align(center, 
text[
题目：实现一元稀疏多项式计算器\
朱雨田~~~~~PB23050888
]
)


#linebreak()
= 一、需求分析

本实验要求实现一元稀疏多项式简单计算器的基本功能：

1. 输入并建立多项式；
2. 输出多项式，输出形式为整数序列：$n,c_1,e_1,c_2,e_2,...,c_n,e_n$，其中 $n$ 为多项式项数，$c_i$ 和 $e_i$ 分别是第 $i$ 项的系数和指数，序数按指数降序排列；

= 二、概要设计

= 三、详细设计

= 四、调试分析
1. 本程序实现了对多项式数学格式输入的 Parser，但这一解析器无法判断输入的格式不合法并抛出错误，使得对于错误的输入，解析器仍然会不合预期地输出一个多项式。事实上，在后续 GUI 的设计中，我设计了一个状态系统用于判断并修正错误的输入。在 Parser 中也应使用这样的状态系统，以过滤不合法的输入。
2. 本程序的模块划分与对操作的分层封装较为合理。本程序将对链表的直接操作概括成“有序插入一项”、“整理合并同类项”和“清空整个多项式”三种，其余的功能均通过这三种操作间接实现（除了求导操作为了在避免引入栈结构前提下优化时间复杂度，而直接操作了链表）。例如，加法设计成将多项式 B 的每一项插入已经保持有序的 A 中，而乘法设计成将多项式 A、B 逐项相乘，将相乘得到的每一项插入到新的多项式 C 中。运算操作不用直接操作链表本身，这使得我们规避了许多可能发生的内存问题，也简化了程序的编写。
3. 算法的时空分析
	1. 有序表采用带头节点的有序单链表，使得 
4. 本实验作业采用数据抽象的程序设计方法，将程序划分为多个层次结构：元素节点、有序链表、链表的基础操作模块（插入、整理、清空）、多项式运算模块、多项式输入输出模块、用户指令处理模块（或 GUI 模块）。这使得设计时思路清晰，实现时调试顺利，各模块具有较好的可重用性，确实得到了一次良好的程序设计训练。

= 五、用户手册

== 1. 命令行

== 2. 图形界面

= 六、测试结果

= 七、附录